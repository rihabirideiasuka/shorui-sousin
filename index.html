<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>書類アップロード</title>

<style>
  *,*::before,*::after{box-sizing:border-box}
  :root{--primary:#1556d1;--danger:#ef5753;--ok:#137333;--fg:#111;--muted:#666;--bg:#f6f7fb;--card:#fff}
  html,body{background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans JP',sans-serif;line-height:1.6;margin:0}
  .wrap{max-width:880px;margin:0 auto;padding:20px}
  .card{background:var(--card);border-radius:18px;box-shadow:0 2px 14px rgba(0,0,0,.06);padding:20px}
  h1{font-size:22px;margin:0 0 8px}
  label{display:block;font-weight:600;margin:14px 0 6px}
  input[type="text"]{width:100%;padding:14px 16px;border:1px solid #ddd;border-radius:14px;font-size:16px}

  .btn{appearance:none;border:0;border-radius:14px;padding:14px 16px;font-weight:700;font-size:16px;cursor:pointer;transition:transform .02s ease}
  .btn:active{transform:translateY(1px)}
  .btn-primary{background:var(--primary);color:#fff}
  .btn-danger{background:var(--danger);color:#fff}
  .btn[disabled]{opacity:.6;cursor:not-allowed}

  .btn-row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:12px 0}
  .btn-bar{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0}

  .hint{font-size:14px;color:var(--muted);margin:6px 0}
  .mini{font-size:12px;color:var(--muted);margin-top:4px}

  .msg{padding:12px 14px;border-radius:12px;margin:10px 0;font-size:16px}
  .msg-ok{background:#e9f5ee;color:var(--ok);border:1px solid #bfe5cd}
  .msg-bad{background:#fdecec;color:#a12121;border:1px solid #f3c3c0}
  .msg-info{background:#eef3ff;color:#274291;border:1px solid #cfdcff}

  .thumbs{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:12px;margin-top:10px}
  .thumb{background:#fafafa;border:1px solid #eee;border-radius:14px;overflow:hidden}
  .thumb img{width:100%;height:120px;object-fit:cover;display:block;background:#fff}
  .thumb .meta{padding:8px 10px;font-size:14px}
  .thumb .row{display:flex;justify-content:space-between;gap:8px;align-items:center}
  .remove{background:#ffe7e7;color:#a12121;border:0;border-radius:10px;padding:6px 8px;font-weight:700;cursor:pointer}

  .progress{height:10px;background:#e8eefc;border-radius:999px;overflow:hidden;margin:10px 0 0}
  .bar{width:40%;height:100%;background:var(--primary);animation:indef 1.2s infinite}
  @keyframes indef{0%{transform:translateX(-60%)}100%{transform:translateX(160%)}}

  .done{display:none;margin-top:14px}.done.show{display:block}
  .done h2{margin:0 0 6px;font-size:22px}

  /* カメラモーダル */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.75);display:none;align-items:center;justify-content:center;padding:0;z-index:9999}
  .modal.show{display:flex}
  .cam{background:#000;width:100%;max-width:1000px;color:#fff;display:flex;flex-direction:column;height:100svh}
  .cam video{flex:1 1 auto;width:100%;height:auto;object-fit:cover}
  .cam .controls{display:flex;gap:10px;justify-content:space-between;padding:12px;background:rgba(0,0,0,.6)}
  .cam .btn{flex:1;padding:14px;border-radius:12px}

  /* トースト */
  .toast{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#e9f5ee;color:#0b6e3f;border:1px solid #bfe5cd;
         padding:10px 14px;border-radius:999px;box-shadow:0 4px 16px rgba(0,0,0,.15);z-index:10000;display:none}
  .toast.show{display:block;animation:fade 2.4s ease forwards}
  @keyframes fade{0%{opacity:0;transform:translate(-50%,-6px)}10%{opacity:1;transform:translate(-50%,0)}90%{opacity:1}100%{opacity:0}}

  /* 枚数バッジ */
  .badge{
    display:inline-block;min-width:1.6em;padding:0 .45em;margin-left:.5em;font-size:.85em;font-weight:700;line-height:1.6em;
    text-align:center;color:#1556d1;background:#fff;border:2px solid #fff;border-radius:999px;vertical-align:middle;
  }
  .badge[hidden]{display:none}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>書類アップロード</h1>

      <form id="f" autocomplete="off" novalidate>
        <label>利用者名・CM名 等（任意）</label>
        <input type="text" id="note" placeholder="例）山田 太郎／CM名／事業所名 など" />

        <label>写真・PDF</label>

        <div class="btn-row">
          <button type="button" class="btn btn-primary" id="pickBtn">📁 アルバムから写真を選択して送る</button>
          <button type="button" class="btn btn-primary" id="camBtn">📸 写真を撮影して送る</button>
        </div>
        <div class="mini">※ 画像が25MB超の場合、送信時に自動で最小限の最適化を行います（PNGは透過保持）。</div>

        <input id="pick" type="file" accept="image/jpeg,image/png,application/pdf" multiple style="display:none">
        <!-- フォールバック用（プログラムクリック互換のため非表示にしすぎない） -->
        <input id="cameraFile" type="file" accept="image/*" capture="environment"
               style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">

        <div class="btn-bar">
          <button type="button" class="btn btn-danger" id="clearBtn">✖ すべて削除</button>
        </div>

        <p class="hint">※ 1ファイル上限：<strong>25MB</strong>　対応形式：<strong>jpeg / png / pdf</strong></p>

        <div id="precheck" class="msg msg-info" role="status" aria-live="polite">選択されたファイルはありません。</div>
        <div class="thumbs" id="thumbs" aria-live="polite"></div>

        <div class="btn-bar" style="margin-top:14px">
          <button class="btn btn-primary" id="sendBtn" type="submit" disabled>⬆ 送信する</button>
        </div>

        <div id="sending" class="msg msg-info" style="display:none" role="status" aria-live="assertive">
          ⏳ アップロード中です。画面を閉じないでください。
          <div class="progress"><div class="bar"></div></div>
        </div>

        <div id="done" class="msg msg-ok done" role="status" aria-live="assertive">
          <h2>✅ アップロードが完了しました（成功）</h2>
        </div>
      </form>
    </div>
  </div>

  <!-- カメラモーダル -->
  <div id="camModal" class="modal" aria-hidden="true">
    <div class="cam" role="dialog" aria-label="カメラで撮影">
      <video id="camVideo" autoplay playsinline></video>
      <div class="controls">
        <button type="button" class="btn" id="camClose">完了して閉じる</button>
        <button type="button" class="btn btn-primary" id="camShot">
          撮影して追加 <span id="shotBadge" class="badge" hidden>0</span>
        </button>
      </div>
    </div>
  </div>

  <!-- トースト -->
  <div id="toast" class="toast">✅ 追加しました</div>

  <!-- iOSの初回再生制限対策（透明ボタン） -->
  <button id="audioUnlock" style="position:fixed;inset:0;opacity:0;pointer-events:none;border:0;background:transparent"></button>

<script>
  /* ==== あなたの GAS /exec に変更 ==== */
  const API_ENDPOINT = 'https://script.google.com/macros/s/AKfycbzsiYOwt1Bcdsg5XM0ejEB9csC9i9qWXabNN-GqdMO60Dxe6sdjet44D9KHDC7ttoal/exec';
  /* ================================== */

  const ALLOW_MIME = ['image/jpeg','image/png','application/pdf'];
  const MAX_BYTES  = 25*1024*1024;

  const queue=[]; const $=s=>document.querySelector(s);
  const pickInput=$('#pick'), cameraFile=$('#cameraFile');
  const thumbs=$('#thumbs'), precheck=$('#precheck');
  const sendBtn=$('#sendBtn'), sending=$('#sending');
  const doneBox=$('#done');
  const toast=$('#toast');

  // カメラ
  const camModal=$('#camModal'), camVideo=$('#camVideo');
  const camClose=$('#camClose'), camShot=$('#camShot');
  const shotBadge = document.getElementById('shotBadge');
  let camStream=null, camAdded=0;

  /* ====== サウンド（強化） ====== */
  const SHUTTER_VOLUME = 1.0;
  const FALLBACK_WAV_BASE64 =
    'UklGRm0XAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YUsXAACAgIDAwMDw8PD4+Pj9/f3////7+/v39/fz8/Pr6+vj4+Pf39/v7+/wAAAP39/fj4+Pr6+vz8/P/////7+/v39/f4+Pj5+fn7+/v9/f0AAAABAQEBAgICAwMDAwQEBAUFBQYGBgcHBwgICAkJCQoKCgoLCwsMDQ0NDg4ODw8PEBAQERER'
    +'EhISExMTFhYWFxcXGBgYGRkZGhoaGxsbHBwcHR0dHh4eHx8fICAgISEhIiIiIyMjJCQkJSUlJiYmJycnKioqKysrLCwsLS0tLi4uLy8v';
  const shutterAudio = new Audio('data:audio/wav;base64,' + FALLBACK_WAV_BASE64);
  shutterAudio.preload = 'auto'; shutterAudio.playsInline = true;
  shutterAudio.setAttribute('webkit-playsinline',''); shutterAudio.volume = SHUTTER_VOLUME;

  let actx=null, audioUnlocked=false;
  async function ensureAudioUnlocked(){
    try{
      if(!actx) actx = new (window.AudioContext||window.webkitAudioContext)();
      if(actx.state==='suspended') await actx.resume();
      audioUnlocked=true;
    }catch(_){}
  }
  function playShutterStrong(){
    if(!actx) actx = new (window.AudioContext||window.webkitAudioContext)();
    const now=actx.currentTime;
    const master=actx.createGain(); master.gain.value=SHUTTER_VOLUME; master.connect(actx.destination);
    // ピ（80ms）
    const beep=actx.createOscillator(), gB=actx.createGain();
    beep.type='sine'; beep.frequency.setValueAtTime(880,now);
    gB.gain.setValueAtTime(0.0001,now); gB.gain.exponentialRampToValueAtTime(0.9,now+0.01);
    gB.gain.exponentialRampToValueAtTime(0.0001,now+0.09);
    beep.connect(gB).connect(master); beep.start(now); beep.stop(now+0.1);
    // クリック（60ms）
    const clk=actx.createOscillator(), gC=actx.createGain();
    clk.type='triangle'; clk.frequency.setValueAtTime(2000,now+0.09); clk.frequency.exponentialRampToValueAtTime(700,now+0.15);
    gC.gain.setValueAtTime(0.0001,now+0.09); gC.gain.exponentialRampToValueAtTime(1.0,now+0.095);
    gC.gain.exponentialRampToValueAtTime(0.0001,now+0.17);
    clk.connect(gC).connect(master); clk.start(now+0.09); clk.stop(now+0.18);
    // ノイズ（140ms）
    const durN=0.14, buf=actx.createBuffer(1,Math.ceil(actx.sampleRate*durN),actx.sampleRate);
    const ch=buf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*0.7;
    const noise=actx.createBufferSource(); noise.buffer=buf;
    const bp=actx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=2000; bp.Q.value=1.0;
    const hp=actx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=500;
    const gN=actx.createGain(); gN.gain.setValueAtTime(0.0001,now+0.09);
    gN.gain.exponentialRampToValueAtTime(0.9,now+0.10); gN.gain.exponentialRampToValueAtTime(0.0001,now+0.22);
    noise.connect(bp).connect(hp).connect(gN).connect(master); noise.start(now+0.09); noise.stop(now+0.23);
    // 低音（120ms）
    const low=actx.createOscillator(), gL=actx.createGain();
    low.type='sine'; low.frequency.setValueAtTime(140,now+0.13);
    gL.gain.setValueAtTime(0.0001,now+0.13); gL.gain.exponentialRampToValueAtTime(0.6,now+0.135);
    gL.gain.exponentialRampToValueAtTime(0.0001,now+0.26);
    low.connect(gL).connect(master); low.start(now+0.13); low.stop(now+0.27);
  }
  async function playShutter(){
    try{ await ensureAudioUnlocked(); playShutterStrong(); return; }catch(_){}
    try{ shutterAudio.currentTime=0; await shutterAudio.play(); return; }catch(_){}
    if(navigator.vibrate) navigator.vibrate(40);
  }
  function primeAudioOnce(){
    if(audioUnlocked) return; audioUnlocked=true; ensureAudioUnlocked();
    const btn=document.getElementById('audioUnlock'); btn.style.pointerEvents='auto';
    setTimeout(()=>{btn.style.pointerEvents='none'},0);
  }
  window.addEventListener('touchstart', primeAudioOnce, { once:true, passive:true });
  window.addEventListener('mousedown', primeAudioOnce, { once:true });

  /* ===== 各種UI操作 ===== */
  $('#pickBtn').onclick=()=>pickInput.click();
  $('#camBtn').onclick =()=>openCameraOrFallback();
  $('#clearBtn').onclick=()=>{queue.length=0;render();};

  pickInput.addEventListener('change',e=>{ for(const f of e.target.files) queue.push(f); e.target.value=''; render(); });
  cameraFile.addEventListener('change',e=>{ if(e.target.files[0]) queue.push(e.target.files[0]); e.target.value=''; render(); });

  /* ===== カメラ起動 ===== */
  async function openCameraOrFallback(){
    if(!navigator.mediaDevices?.getUserMedia){ cameraFile.click(); return; }
    try{
      camStream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' },
          width:  { ideal: 4032 },
          height: { ideal: 3024 },
          advanced: [{ width: 4032, height: 3024 }]
        },
        audio: false
      });
      camVideo.srcObject=camStream;
      if (camVideo.readyState < 2) await new Promise(ok => camVideo.addEventListener('loadeddata', ok, {once:true}));
      camModal.classList.add('show');
      camModal.setAttribute('aria-hidden','false');
      document.body.style.overflow='hidden';
      camAdded=0; updateShotBadge();
    }catch(e){ cameraFile.click(); }
  }
  function stopCamera(){
    if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; }
    camVideo.srcObject=null;
    camModal.classList.remove('show');
    camModal.setAttribute('aria-hidden','true');
    document.body.style.overflow='';
    camAdded=0; updateShotBadge();
  }
  camClose.onclick=()=>{ stopCamera(); render(); };

  /* ====== 互換ヘルパ ====== */
  async function blobFromCanvas(canvas, mime='image/jpeg', quality=1.0){
    if (canvas.toBlob){
      const b = await new Promise(res=>canvas.toBlob(res, mime, quality));
      if (b) return b;
    }
    const dataUrl = canvas.toDataURL(mime, quality);
    try{ return await (await fetch(dataUrl)).blob(); }
    catch(_){
      const b64 = dataUrl.split(',')[1]||''; const bin=atob(b64);
      const u8 = new Uint8Array(bin.length); for(let i=0;i<u8.length;i++) u8[i]=bin.charCodeAt(i);
      return new Blob([u8],{type:mime});
    }
  }
  function toFileLike(blob, name){
    try{ return new File([blob], name, { type: blob.type||'image/jpeg' }); }
    catch(_){
      try{ Object.defineProperty(blob,'name',{value:name}); }catch(__){}
      return blob;
    }
  }

  // ImageCapture優先（失敗時canvas）
  async function camSnapBest() {
    const track = camStream?.getVideoTracks?.()[0];
    if (track && 'ImageCapture' in window) {
      try {
        const ic = new ImageCapture(track);
        let settings = {};
        if (ic.getPhotoCapabilities) {
          const cap = await ic.getPhotoCapabilities();
          if (cap?.imageWidth && cap?.imageHeight) {
            settings.imageWidth  = cap.imageWidth.max;
            settings.imageHeight = cap.imageHeight.max;
          }
        }
        const blob = await ic.takePhoto(settings); // 多くの環境でEXIF保持＆高解像度
        return blob;
      } catch (_) { /* fallback */ }
    }
    // fallback: プレビュー解像度→JPEG(品質1.0)
    const s = track?.getSettings?.() || {};
    const w = camVideo.videoWidth || s.width || 1280;
    const h = camVideo.videoHeight || s.height || 720;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(camVideo, 0, 0, w, h);
    return await blobFromCanvas(c, 'image/jpeg', 1.0);
  }

  /* ===== 連続撮影 ===== */
  camShot.onclick=async ()=>{
    if(!camStream) return;
    try{
      const blob = await camSnapBest();
      await playShutter();

      const d=new Date(), z=n=>String(n).padStart(2,'0');
      const name=`${d.getFullYear()}${z(d.getMonth()+1)}${z(d.getDate())}_${z(d.getHours())}${z(d.getMinutes())}${z(d.getSeconds())}.jpg`;

      const fileLike = toFileLike(blob, name);
      queue.push(fileLike);
      camAdded++; updateShotBadge();
      showToast(`✅ 追加しました（合計 ${camAdded} 件）`);
      render();
    }catch(err){
      showToast('⚠️ 撮影の追加に失敗しました。端末のカメラ権限やブラウザを確認してください。');
      if (navigator.vibrate) navigator.vibrate(30);
      console.error(err);
    }
  };

  function updateShotBadge(){
    shotBadge.hidden = camAdded <= 0;
    if (camAdded > 0) shotBadge.textContent = camAdded;
  }

  function showToast(msg){
    toast.textContent=msg;
    toast.classList.remove('show');
    requestAnimationFrame(()=>{ toast.classList.add('show'); });
  }

  /* ===== 画面更新 ===== */
  function render(){
    thumbs.innerHTML='';
    if(queue.length>0) doneBox.classList.remove('show');
    if(!queue.length){
      precheck.className='msg msg-info';
      precheck.textContent='選択されたファイルはありません。';
      sendBtn.disabled=true; return;
    }

    queue.forEach((f,i)=>{
      const card=document.createElement('div'); card.className='thumb';
      const img=document.createElement('img');
      if((f.type||'').startsWith('image/')){ img.src=URL.createObjectURL(f); img.onload=()=>URL.revokeObjectURL(img.src); }
      else { img.alt='ファイル'; img.style.background='#eef3ff'; }
      const displayName = (f.name || 'capture.jpg');
      const meta=document.createElement('div'); meta.className='meta';
      meta.innerHTML=`<div class="row"><strong>${escapeHtml(displayName)}</strong></div>
                      <div class="row"><span>${(f.size/1024/1024).toFixed(1)} MB</span>
                      <button type="button" class="remove" data-i="${i}">削除</button></div>`;
      card.appendChild(img); card.appendChild(meta); thumbs.appendChild(card);
    });
    document.querySelectorAll('.remove').forEach(b=>b.onclick=e=>{ queue.splice(Number(e.currentTarget.dataset.i),1); render(); });

    // 非画像のみ25MB超でブロック（画像は送信時に最小限最適化）
    const overs=queue.filter(f=>!(f.type||'').startsWith('image/') && f.size>MAX_BYTES);
    if(overs.length){
      precheck.className='msg msg-bad';
      precheck.innerHTML=`⚠ 非画像ファイルが上限<strong>${Math.round(MAX_BYTES/1024/1024)}MB</strong>を超えています：<br>${
        overs.map(f=>`${escapeHtml((f.name||'ファイル'))}（${(f.size/1024/1024).toFixed(1)}MB）`).join('、 ')
      }`; sendBtn.disabled=true; return;
    }
    if(queue.some(f=>!ALLOW_MIME.includes((f.type||'').toLowerCase()))){
      precheck.className='msg msg-bad';
      precheck.innerHTML='⚠ 送信できない形式が含まれています（jpeg / png / pdfのみ）。';
      sendBtn.disabled=true; return;
    }

    const sum=queue.reduce((s,f)=>s+f.size,0);
    precheck.className='msg msg-ok';
    precheck.innerHTML=`👍 送信できます。選択枚数：<strong>${queue.length}</strong>、合計：約<strong>${(sum/1024/1024).toFixed(1)}MB</strong><div class="mini">※ 画像が25MB超の場合は送信時に自動最適化します。</div>`;
    sendBtn.disabled=false;
  }

  // 送信
  document.getElementById('f').addEventListener('submit',(e)=>{
    e.preventDefault(); if(!queue.length) return;
    (async ()=>{
      sendBtn.disabled=true;
      sending.style.display='block';
      sending.scrollIntoView({behavior:'smooth', block:'start'});

      const note = document.getElementById('note').value || '';

      for (const f of queue){
        try{
          const packed = await packToLimit(f, MAX_BYTES);
          const payload = { note, items:[{ name:(f.name||'capture.jpg'), mime:packed.mime, base64:packed.base64 }] };
          const url = API_ENDPOINT + '?origin=' + encodeURIComponent(location.origin);
          await fetch(url, { method:'POST', headers:{'Content-Type':'text/plain'}, body:JSON.stringify(payload), mode:'no-cors' });
        }catch(_){}
      }

      sending.style.display='none';
      doneBox.classList.add('show');
      queue.length=0; render();
      sendBtn.disabled=false;
    })();
  });

  /* ===== ユーティリティ ===== */
  function readFileAsDataURL(file){ return new Promise((ok,ng)=>{ const r=new FileReader(); r.onload=()=>ok(r.result); r.onerror=ng; r.readAsDataURL(file); }); }
  function loadImage(url){ return new Promise((ok,ng)=>{ const i=new Image(); i.onload=()=>ok(i); i.onerror=ng; i.src=url; }); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&quot;',"'":'&#39;'}[c])); }

  // 透過の有無を簡易判定
  async function hasAlphaChannel(img){
    const w = Math.min(img.width, 512), h = Math.min(img.height, 512);
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
    const data = ctx.getImageData(0,0,w,h).data;
    for(let i=3; i<data.length; i+=16){ if(data[i] < 255) return true; }
    return false;
  }

  // 25MB以内に収める最小限最適化（画像は品質優先、PNGは透過保持）
  async function packToLimit(file, maxBytes){
    if(!((file.type||'').startsWith('image/'))) {
      const dataUrl = await readFileAsDataURL(file);
      const base64 = dataUrl.split(',')[1]; const bytes = Math.ceil(base64.length*3/4);
      return { base64, bytes, mime:(file.type||'application/octet-stream') };
    }

    // そのまま試す
    let dataUrl = await readFileAsDataURL(file);
    let base64  = dataUrl.split(',')[1];
    let bytes   = Math.ceil(base64.length*3/4);
    if (bytes <= maxBytes) return { base64, bytes, mime:file.type||'image/jpeg' };

    const img = await loadImage(dataUrl);
    const isPng = /^image\/png$/i.test(file.type||'');
    const alpha = isPng ? await hasAlphaChannel(img) : false;

    // JPEG系 または アルファなし画像：まず品質だけ落とす（解像度維持）
    if (!isPng || !alpha){
      let lo = 0.82, hi = 0.98, best = null;
      for (let i=0; i<6; i++){
        const q = (lo+hi)/2;
        const c = document.createElement('canvas'); c.width = img.width; c.height = img.height;
        const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
        ctx.drawImage(img,0,0);
        const out = c.toDataURL('image/jpeg', q);
        const b64 = out.split(',')[1]; const b = Math.ceil(b64.length*3/4);
        if (b <= maxBytes){ best = { base64:b64, bytes:b, mime:'image/jpeg' }; lo = q; } else { hi = q; }
      }
      if (best) return best;

      // まだ大きい → 必要分だけ縮小して 0.9
      const ratio = Math.max(0.1, Math.sqrt(maxBytes/bytes)*0.96);
      const cw = Math.max(1, Math.round(img.width*ratio));
      const ch = Math.max(1, Math.round(img.height*ratio));
      const c2 = document.createElement('canvas'); c2.width=cw; c2.height=ch;
      const ctx2 = c2.getContext('2d'); ctx2.imageSmoothingEnabled = true; ctx2.imageSmoothingQuality='high';
      ctx2.drawImage(img,0,0,cw,ch);
      const out2 = c2.toDataURL('image/jpeg', 0.9);
      const b64_2 = out2.split(',')[1]; const b2 = Math.ceil(b64_2.length*3/4);
      return { base64:b64_2, bytes:b2, mime:'image/jpeg' };
    }

    // PNGかつ透過あり：透過保持で縮小（品質指定なし）
    let ratio = Math.max(0.1, Math.sqrt(maxBytes/bytes)*0.98);
    let cw = Math.max(1, Math.round(img.width*ratio));
    let ch = Math.max(1, Math.round(img.height*ratio));
    for (let tries=0; tries<3; tries++){
      const c = document.createElement('canvas'); c.width=cw; c.height=ch;
      const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(img,0,0,cw,ch);
      const out = c.toDataURL('image/png');
      const b64 = out.split(',')[1]; const b = Math.ceil(b64.length*3/4);
      if (b <= maxBytes) return { base64:b64, bytes:b, mime:'image/png' };
      cw = Math.max(1, Math.round(cw * 0.85));
      ch = Math.max(1, Math.round(ch * 0.85));
    }

    // 最終手段：JPEG化（透過は失われます）
    {
      const c = document.createElement('canvas'); c.width=cw; c.height=ch;
      const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(img,0,0,cw,ch);
      const out = c.toDataURL('image/jpeg', 0.9);
      const b64 = out.split(',')[1]; const b = Math.ceil(b64.length*3/4);
      return { base64:b64, bytes:b, mime:'image/jpeg' };
    }
  }

  // 初期描画
  render();
</script>
</body>
</html>
